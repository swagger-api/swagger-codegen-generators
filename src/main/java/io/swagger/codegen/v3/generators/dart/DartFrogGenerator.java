package io.swagger.codegen.v3.generators.dart;

import io.swagger.codegen.v3.*;
import io.swagger.codegen.v3.generators.DefaultCodegenConfig;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.Paths;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.responses.ApiResponse;

import java.util.*;
import com.github.jknack.handlebars.Handlebars;
import com.github.jknack.handlebars.helper.ConditionalHelpers;
import com.github.jknack.handlebars.helper.StringHelpers;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;

public class DartFrogGenerator extends DefaultCodegenConfig {
  // source folder where to write the files
  protected String sourceFolder = "lib";
  protected String routesFolder = "routes";
  protected String modelsFolder = "models";
  protected String publicFolder = "public";
  protected String testsFolder = "tests";
  protected String apiVersion = "1.0.0";

  /**
   * Configures the type of generator.
   * 
   * @return the CodegenType for this generator
   * @see io.swagger.codegen.CodegenType
   */
  public CodegenType getTag() {
    return CodegenType.SERVER;
  }

  /**
   * Configures a friendly name for the generator. This will be used by the
   * generator
   * to select the library with the -l flag.
   * 
   * @return the friendly name for the generator
   */
  public String getName() {
    return "dart-frog";
  }

  /**
   * Returns human-friendly help for the generator. Provide the consumer with help
   * tips, parameters here
   * 
   * @return A string value for the help message
   */
  public String getHelp() {
    return "Generates a dart-frog server stub.";
  }

  public DartFrogGenerator() {
    super();

    // set the output folder here
    outputFolder = "generated-code/dart-frog";

    /**
     * Models. You can write model files using the modelTemplateFiles map.
     * if you want to create one template for file, you can do so here.
     * for multiple files for model, just put another entry in the
     * `modelTemplateFiles` with
     * a different extension
     */
    modelTemplateFiles.put(
        "model.dart.mustache", // the template to use
        ".dart"); // the extension for each file to write

    /**
     * Api classes. You can write classes for each Api file with the
     * apiTemplateFiles map.
     * as with models, add multiple entries with different extensions for multiple
     * files per
     * class
     */
    apiTemplateFiles.put(
        "route.dart.mustache", // the template to use
        ".dart"); // the extension for each file to write

    /**
     * Template Location. This is the location which templates will be read from.
     * The generator
     * will use the resource stream to attempt to read the templates.
     */
    templateDir = "handlebars/dart-frog";

    /**
     * Api Package. Optional, if needed, this can be used in templates
     */
    apiPackage = "io.swagger.dart_frog.api";

    /**
     * Reserved words. Override this with reserved words specific to your language
     */
    reservedWords = new HashSet<String>(
        Arrays.asList(
            "abstract", "as", "assert", "async", "async*", "await",
            "break", "case", "catch", "class", "const", "continue",
            "default", "deferred", "do", "dynamic", "else", "enum",
            "export", "external", "extends", "factory", "false", "final",
            "finally", "for", "get", "if", "implements", "import", "in",
            "is", "library", "new", "null", "operator", "part", "rethrow",
            "return", "set", "static", "super", "switch", "sync*", "this",
            "throw", "true", "try", "typedef", "var", "void", "while",
            "with", "yield", "yield*"));

    /**
     * Additional Properties. These values can be passed to the templates and
     * are available in models, apis, and supporting files
     */
    additionalProperties.put("apiVersion", apiVersion);
    /// `httpVerbs` are needed for iterating through them in routes template
    additionalProperties.put("httpVerbs", new String[] {
        "GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS" });
    // additionalProperties.put("appDescription", 
    //   "dart_frog realization of the server stub of the application \"" + 
    //   openAPI.getInfo().getTitle() + 
    //   "\" generated by Swagger Codegen");

    /**
     * Supporting Files. You can write single files for the generator with the
     * entire object tree available. If the input file has a suffix of `.mustache
     * it will be processed by the template engine. Otherwise, it will be copied
     */
    supportingFiles.addAll(Arrays.asList(
      new SupportingFile("pubspec.yaml.mustache", "", "pubspec.yaml"),
      new SupportingFile("main.dart.mustache", "main.dart")));

    /**
     * Language Specific Primitives. These types will not trigger imports by
     * the client generator
     */
    languageSpecificPrimitives = new HashSet<String>(
        Arrays.asList(
            "bool",
            "int",
            "num",
            "double",
            "DateTime",
            "List",
            "Object",
            "String"));

    typeMapping = new HashMap<String, String>() {{
        put("Array", "List");
        put("array", "List");
        put("List", "List");
        put("boolean", "bool");
        put("string", "String");
        put("char", "String");
        put("int", "int");
        put("long", "int");
        put("short", "int");
        put("number", "num");
        put("float", "double");
        put("double", "double");
        put("BigDecimal", "double");
        put("object", "Object");
        put("integer", "int");
        put("Date", "DateTime");
        put("date", "DateTime");
        put("File", "MultipartFile");
        put("UUID", "String");
        put("GUID", "String");
    }};
  }

  /**
   * Escapes a reserved word as defined in the `reservedWords` array. Handle
   * escaping
   * those terms here. This logic is only called if a variable matches the
   * reserved words
   * 
   * @return the escaped term
   */
  @Override
  public String escapeReservedWord(String name) {
    return "_" + name; // add an underscore to the name
  }

  /**
   * Location to write model files. You can use the modelPackage() as defined when
   * the class is
   * instantiated
   */
  public String modelFileFolder() {
    return outputFolder + "/" + sourceFolder + "/" + modelsFolder;
  }

  /**
   * Location to write API files.
   * For Dart Frog it's %PROJECT_ROOT%/routes
   */
  @Override
  public String apiFileFolder() {
    return outputFolder + "/" + routesFolder;
  }

  /**
   * Returns file name of the API tag. For Dart Frog tag is used to identify
   * the path. So each path is represented with it's own file.
   * The folder structure of all files matches structure of paths.
   * So the list of paths:
   * 
   * /a
   * /a/b
   * /a/b/c
   * /b
   * /b/d
   * 
   * will end up with file structure:
   * /a
   *   /index.dart
   *   /b
   *     /index.dart
   *     /c.dart
   * /b
   *   /index.dart
   *   /d.dart
   */
  @Override
  public String toApiFilename(String name) {
    if (name.substring(name.length() - 1).equals("/")) {
      name = name + "index";
    }
    return name
        .substring(1)
        .replace('{', '[')
        .replace('}', ']');
  }

  /**
   * Dart file naming convention is snake case
   * https://dart.dev/effective-dart/style#do-name-packages-and-file-system-entities-using-lowercase-with-underscores
   * @param name - Class name, for which need to get file name
   */
  @Override
  public String toModelFilename(String name) {
    return snakeCase(name);  
  }

  /**
   * Original method doesn't really make a snake_case
   */
  @Override
  public String snakeCase(String camelCase) {
    StringBuilder snakeCase = new StringBuilder();
    boolean previousCharWasUpperCase = false;
    
    for (int i = 0; i < camelCase.length(); i++) {
        char currentChar = camelCase.charAt(i);
        
        if (Character.isUpperCase(currentChar)) {
            if (i > 0 && !previousCharWasUpperCase) {
                snakeCase.append('_');
            }
            snakeCase.append(Character.toLowerCase(currentChar));
            previousCharWasUpperCase = true;
        } else {
            snakeCase.append(currentChar);
            previousCharWasUpperCase = false;
        }
    }
    
    return snakeCase.toString();
}

  /**
   * @param name - Class name to be imported
   */
  @Override
  public String toModelImport(String name) {
    return "package:" + openAPI.getInfo().getTitle() + "/" + modelsFolder +
        "/" + toModelFilename(name) + ".dart";
  }

  @Override
  protected String getTemplateDir() {
    return templateDir;
  }

  @Override
  public String getDefaultTemplateDir() {
    return templateDir;
  }

  /**
   * Customize a standard operation adding process by setting the path as a
   * tag with trailing slash if the path isn't the finite for whole set of
   * paths.
   * It is needed to group all operations by paths because for Dart Frog each
   * path is implemented in its own route file
   */
  @Override
  public void addOperationToGroup(String tag, String resourcePath,
      Operation operation, CodegenOperation co,
      Map<String, List<CodegenOperation>> operations) {
    super.addOperationToGroup(
        addTrailingSlash(resourcePath), resourcePath, operation, co, operations);
  }

  private String addTrailingSlash(String resourcePath) {
    Set<String> paths = openAPI.getPaths().keySet();
    String slash = "";
    for (String path : paths) {
      if (resourcePath.equals(path)) {
        continue;
      }
      if (path.startsWith(resourcePath)) {
        slash = "/";
        break;
      }
    }
    return resourcePath + slash;
  }

  /**
   * Registers additional helpers for Handlebars template engine
   * Needed here in order to enable `eq` and `lower` helpers, which is part
   * of Java's realization of Handlebars but isn't registered by default.
   */
  @Override
  public void addHandlebarHelpers(Handlebars handlebars) {
    super.addHandlebarHelpers(handlebars);
    handlebars.registerHelpers(ConditionalHelpers.class);
    handlebars.registerHelpers(StringHelpers.class);
  }

  /**
   * Parameters handler of DefaultCodegen gets parameters from single operations
   * and ignores path level parameters. 
   * Therefore, this preprocessor creates parameters list for all operations of
   * path, that has path level parameters
   */
  @Override
  public void preprocessOpenAPI(OpenAPI openAPI) {
    super.preprocessOpenAPI(openAPI);
    Paths paths = openAPI.getPaths();
    for (String pathStr : paths.keySet()) {
      PathItem path = paths.get(pathStr);
      if (path.getParameters() != null && !path.getParameters().isEmpty()) {
        initParametersList(path.getGet());
        initParametersList(path.getPost());
        initParametersList(path.getPut());
        initParametersList(path.getPatch());
        initParametersList(path.getOptions());
        initParametersList(path.getDelete());
        initParametersList(path.getHead());
      }
    }
    saveSpec(inputURL);
  }

  private void initParametersList(Operation op) {
    if (op != null && op.getParameters() == null) {
      op.setParameters(new ArrayList<Parameter>());
    }
  }

  /**
   * Gets input OpenAPI specification either from local file or URL and adds
   * a property so the `openapi.ext` will be saved in public folder
   * @param pathOrUrl
   */
  private void saveSpec(String pathOrUrl) {
    try {
      if (pathOrUrl.startsWith("http://") || pathOrUrl.startsWith("https://")) {
          // Read from URL
          additionalProperties.put("openApiSpec", readFromUrl(pathOrUrl));
      } else {
          // Read from local file
          additionalProperties.put("openApiSpec", readFromFile(pathOrUrl));
      }
      String suffix = pathOrUrl.substring(pathOrUrl.lastIndexOf("."));
      supportingFiles.add(new SupportingFile("openapi.mustache", 
        publicFolder, "openapi" + suffix));
    } catch (IOException e) {
      LOGGER.error("Couldn't get OpenAPI specification", e);
    }
  }

  private String readFromUrl(String urlString) throws IOException {
      StringBuilder content = new StringBuilder();
      URL url = new URL(urlString);

      try (BufferedReader reader = new BufferedReader(
        new InputStreamReader(url.openStream()))) {
          String line;
          while ((line = reader.readLine()) != null) {
              content.append(line).append("\n");
        }
      }

      return content.toString();
  }

  private String readFromFile(String filePath) throws IOException {
      return new String(Files.readAllBytes(java.nio.file.Paths.get(filePath)),
                        StandardCharsets.UTF_8);
  }

  /**
   * Replace `dataType` with Dart type
   */
  @Override
  public CodegenModel fromModel(String name, Schema schema, Map<String, Schema> allDefinitions) {
    CodegenModel model = super.fromModel(name, schema, allDefinitions);
    model.setDataType(typeMapping().get(model.getDataType()));
    return model;
  }

  /**
   * Imports of DefaultGenerator use baseType instead of dataType
   * Therefore, need to set baseType of response to dataType
   * @param responseCode
   * @param response
   * @return CodegenResponse with baseType updated
   */
  @Override
  public CodegenResponse fromResponse(String responseCode, ApiResponse response) {
    CodegenResponse resp = super.fromResponse(responseCode, response);
    if (resp.containerType == null) {
      resp.baseType = resp.dataType;
    }
    return resp;
  }

  /**
   * Complex properties whose type is defined right in property definitnion
   * are marked as `object` but of complex type so it's not recognized as 
   * built-in `Object` of Dart.
   * So, such properties are defined as non-complex and, if their type belongs
   * to Dart built-in types marked as of primitive type
   */
  @Override
  public CodegenProperty fromProperty(String name, Schema propertySchema) {
      CodegenProperty property = super.fromProperty(name, propertySchema);
      boolean isPrimitive = languageSpecificPrimitives.contains(property.getDatatype());
      property.getVendorExtensions().put(
        CodegenConstants.IS_PRIMITIVE_TYPE_EXT_NAME, isPrimitive);
      if (isPrimitive) {
        property.complexType = null;
      }
      return property;
  }

  @Override
  public String getSchemaType(Schema schema) {
    String type = super.getSchemaType(schema);
    String[] typeComponents = type.split("/properties/");
    if (typeComponents.length < 2) {
      return type;
    }
    Schema refSchema = openAPI.getComponents().getSchemas()
      .get(typeComponents[0]);
    if (refSchema == null) {
      return type;
    }
    Schema prop = (Schema)refSchema.getProperties().get(typeComponents[1]);
    return prop.getType();
  }

  @Override
  public String escapeUnsafeCharacters(String input) {
    return input;
  }

  @Override
  public String escapeQuotationMark(String input) {
    return input.replace("\'", "\\\'");
  }

  /**
   * Default needToImport uses types from OpenAPI schema
   * Language-specific ones should be used instead
   */
  @Override
  protected boolean needToImport(String type) {
      return super.needToImport(typeMapping().keySet().contains(type) 
                                  ? typeMapping().get(type) 
                                  : type);
  }

}